#!/usr/bin/python2

#List of messags to consider for OSC translations(!)
#http://www.midi.org/techspecs/midimessages.php

# Send to virtual Midi port
from mido import open_output, set_backend, Backend
def midisender(q):
    #print 'sender'
    rtmidi = Backend('mido.backends.rtmidi')
    set_backend('mido.backends.rtmidi')
    port = rtmidi.open_output("MidiWifiIn",virtual=True)
    while 1:
        m=q.get()
        print m
        port.send(m)

# Monitor for DS messages
from mido import parse
import socket
def dslistener(q):
    port = 9000
    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    s.bind(("", port)) 
    #print "waiting on port:", port
    while 1:
        data, addr = s.recvfrom(1024)
        q.put(parse(data))

# Monitor for WS (websocket)
from mido.sockets import connect, PortServer
def wslistener(q):
    for message in PortServer('192.168.1.29', 5001):
       q.put(message)

# Monitor for OSC messags
import liblo, sys
from mido import Message
def osclistener(q):
    try:
        server = liblo.Server(8000)
    except liblo.ServerError, err:
        print str(err)
        exit()
    def fallback(path, args, types, src):
        # parse message
        msg=['note_off',
            'note_on',
            'polytouch',
            'control_change',
            'program_change',
            'aftertouch',
            'pitchwheel',
            'sysex',
            'quarter_frame',
            'songpos',
            'song_select',
            'tune_request' ,
            'clock' ,
            'start' ,
            'continue' ,
            'stop' ,
            'active_sensing' ,
            'reset']
        cmd = path.split('/')
        if len(cmd)==4 and cmd[0:2]==['','midi'] and cmd[2] in msg:
            m = Message(cmd[2],note=int(float(cmd[3])))
            print m
        else:
            print "got unknown message '%s' from '%s'" % (path, src.url)
            for a, t in zip(args, types):
                print "argument of type '%s': %s" % (t, a)
    # register a fallback for unhandled messages
    server.add_method(None, None, fallback)
    # loop and dispatch messages every 100ms
    while True:
        server.recv(100)

from multiprocessing import Process, Queue
if __name__ == '__main__':
    q = Queue()
    p1 = Process(target=midisender, args=(q,))
    p1.start()
    p2 = Process(target=osclistener, args=(q,))
    p3 = Process(target=dslistener, args=(q,))
    p4 = Process(target=wslistener, args=(q,))
    p2.start()
    p3.start()
    p4.start()
    raw_input('press enter')
    #q.put(['quit']) 
    p4.terminate()
    p3.terminate()
    p2.terminate()
    p1.terminate()
    p4.join
    p3.join
    p2.join
    p1.join
    exit()
